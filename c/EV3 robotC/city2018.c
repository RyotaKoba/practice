#pragma config(Sensor, S1,     ,               sensorEV3_Color)
#pragma config(Sensor, S2,     ,               sensorEV3_Gyro)
#pragma config(Sensor, S3,     ,               sensorEV3_Touch)
#pragma config(Sensor, S4,     ,               sensorEV3_Touch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void motor_encoder(int p);
void Stop_motor(void);
void encoder_reset(void);
void turn(int p);
void left_turn(int p);

task main()
{
	int x=0,y=0,b=0,t=0,o=0,c=0;
	while(SensorValue[S4]==0)
	{
		if(SensorValue[S3]==1)
		{
			x++;
			displayBigTextLine(1,"X:%d",x);
			displayBigTextLine(4,"Y:%d",y);
			wait1Msec(400);
		}
	}
	wait1Msec(500);
	while(SensorValue[S4]==0)
	{
		if(SensorValue[S3]==1)
		{
			y++;
			displayBigTextLine(4,"Y:%d",y);
			wait1Msec(500);
		}
	}
	b=320;
	t=((4-y)+x);
	o=((y-1)+x);
	resetGyro(S2);
	wait1Msec(500);
	displayBigTextLine(6,"gyro:%d",SensorValue[S2]);
	if(x<=4 && x<y)
	{
		motor_encoder(((x+y)*0.5)*b);
		motor[motorB]=10;
		motor[motorC]=10;
		wait1Msec(600);
		Stop_motor();
		resetGyro(S2);
		turn(119);
		encoder_reset();
		motor_encoder(b*y);
		resetGyro(S2);
		left_turn(-100);
		}else{
		motor_encoder(((x-y)*0.5)*b);
		motor[motorB]=10;
		motor[motorC]=10;
		wait1Msec(600);
		Stop_motor();
		resetGyro(S2);
		turn(59);
		encoder_reset();
		motor_encoder(b*y);
		resetGyro(S2);
		left_turn(-60);
	}
	encoder_reset();
	resetGyro(S2);
	c=SensorValue[S1];
	wait1Msec(1000);
	if(c<15)
	{
		if(y<=2)
		{
			motor_encoder(((12-x)*0.5)*b);
			}else{
			resetGyro(S2);
			left_turn(-60);
			motor_encoder((y-1)*b);
			resetGyro(S2);
			turn(60);
			encoder_reset();
			motor_encoder(((12-o)*0.5)*b);
		}
	}
	if(c>20)
	{
		if(y>=3)
		{
			motor_encoder(((12-x)*0.5)*b);
			}else{
			resetGyro(S2);
			turn(60);
			motor_encoder((4-y)*b);
			resetGyro(S2);
			left_turn(-60);
			encoder_reset();
			motor_encoder(((12-t)*0.5)*b);
		}
	}
}
void motor_encoder(int p)
{
	while(nMotorEncoder[motorB]<p)
	{
		motor[motorB]=15;
		motor[motorC]=15;
	}
}
void Stop_motor()
{
	motor[motorB] = 0;
	motor[motorC] = 0;
	wait1Msec(1000);
}
void encoder_reset()
{
	nMotorEncoder[motorB]=0;
}
void turn(int p)
{
	while(SensorValue[S2]<p)
	{
		motor[motorB]=-5;
		motor[motorC]=5;
	}
}
void left_turn(int p)
{
	while(SensorValue[S2]>p)
	{
		motor[motorB]=5;
		motor[motorC]=-5;
	}
}
